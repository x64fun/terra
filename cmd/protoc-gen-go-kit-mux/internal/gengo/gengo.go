package gengo

import (
	"strings"

	"github.com/x64fun/terra/cmd/protoc-gen-go-kit-mux/internal/version"
	"github.com/x64fun/terra/internal/tool"
	"github.com/x64fun/terra/pkg/protofile/kit"

	"github.com/google/uuid"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// SupportedFeatures reports the set of supported protobuf language features.
var SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

// Standard library dependencies.
const (
	contextPackage = protogen.GoImportPath("context")
	errorsPackage  = protogen.GoImportPath("errors")
	netHTTPPackage = protogen.GoImportPath("net/http")
	syncPackage    = protogen.GoImportPath("sync")
	jsonPackage    = protogen.GoImportPath("encoding/json")
	xmlPackage     = protogen.GoImportPath("encoding/xml")
	ioPackage      = protogen.GoImportPath("io")
	ioutilPackage  = protogen.GoImportPath("io/ioutil")
)

// current library dependencies.
const (
	muxPackage  = protogen.GoImportPath("github.com/gorilla/mux")
	uuidPackage = protogen.GoImportPath("github.com/google/uuid")
)

// internal library dependencies.
var (
	internalPowerPackage protogen.GoImportPath
)

const deprecationComment = "// Deprecated: Do not use."

func GeneratePower(gen *protogen.Plugin) *protogen.GeneratedFile {
	goImportPath := gen.Files[0].GoImportPath
	for _, file := range gen.Files {
		if len(file.GoImportPath) < len(goImportPath) {
			goImportPath = file.GoImportPath
		}
	}

	powerImportPath := protogen.GoImportPath(goImportPath + "/power")
	internalPowerPackage = protogen.GoImportPath(powerImportPath)
	filename := "power/power.go"
	g := gen.NewGeneratedFile(filename, powerImportPath)
	g.P("// Code generated by protoc-gen-go-kit-mux. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-kit-mux ", version.String())
	g.P("// - protoc                ", tool.ProtocVersion(gen))
	g.P("package power")
	g.P("/**")
	g.P(" * power")
	g.P(" */")
	g.P("type PowerIndex ", uuidPackage.Ident("UUID"))
	g.P("type Power struct {")
	g.P("	PowerIndex `json:", `"power,omitempty"`, "`")
	g.P("	PowerName  string `json:", `"-"`, "`")
	g.P("	Name       string `json:", `"name,omitempty"`, "`")
	g.P("	Method     string `json:", `"-"`, "`")
	g.P("	URL        string `json:", `"-"`, "`")
	g.P("	MuxPath    string `json:", `"-"`, "`")
	g.P("}")
	g.P("var PowerMap = make(map[PowerIndex]*Power)")
	g.P("func (pi PowerIndex) Method() string {")
	g.P("	return PowerMap[pi].Method")
	g.P("}")
	g.P("func (pi PowerIndex) URL() string {")
	g.P("	return PowerMap[pi].URL")
	g.P("}")
	g.P("func (pi PowerIndex) Name() string {")
	g.P("	return PowerMap[pi].Name")
	g.P("}")
	g.P("func (pi PowerIndex) PowerName() string {")
	g.P("	return PowerMap[pi].PowerName")
	g.P("}")
	g.P("func (pi PowerIndex) MuxPath() string {")
	g.P("	return PowerMap[pi].MuxPath")
	g.P("}")
	g.P()
	g.P("var (")
	for _, f := range gen.Files {
		for _, s := range f.Services {
			for _, m := range s.Methods {
				if !m.Desc.IsStreamingServer() && !m.Desc.IsStreamingClient() {
					if m.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
						g.P(deprecationComment)
					}
					httpRuleAnnotations := m.Desc.Options().ProtoReflect().Get(annotations.E_Http.TypeDescriptor())
					httpRule := annotations.E_Http.InterfaceOf(httpRuleAnnotations).(*annotations.HttpRule)
					if httpRule != nil {
						g.P("	Power", m.GoName, " = ", "PowerIndex(", uuidPackage.Ident("MustParse"), `("`, uuid.New(), `")`, ")")
					}
				}
			}
		}
	}
	g.P(")")
	g.P()
	g.P("func init() {")
	g.P("var once ", syncPackage.Ident("Once"))
	g.P("once.Do(func() {")
	for _, f := range gen.Files {
		for _, s := range f.Services {
			for _, m := range s.Methods {
				if !m.Desc.IsStreamingServer() && !m.Desc.IsStreamingClient() {
					if m.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
						g.P(deprecationComment)
					}
					httpRuleAnnotations := m.Desc.Options().ProtoReflect().Get(annotations.E_Http.TypeDescriptor())
					httpRule := annotations.E_Http.InterfaceOf(httpRuleAnnotations).(*annotations.HttpRule)
					if httpRule != nil {
						g.P("PowerMap[", "Power", m.GoName, "]", " = ", "&Power{")
						g.P("PowerIndex: Power", m.GoName, ",")
						g.P(`PowerName: "`, m.GoName, `",`)
						g.P(`Name: "`, strings.TrimSpace(strings.ReplaceAll(m.Comments.Leading.String(), "//", "")), `",`)
						var router string
						if httpRule.GetGet() != "" {
							g.P("Method: ", netHTTPPackage.Ident("MethodGet"), ",")
							router = httpRule.GetGet()
						}
						if httpRule.GetPost() != "" {
							g.P("Method: ", netHTTPPackage.Ident("MethodPost"), ",")
							router = httpRule.GetPost()
						}
						if httpRule.GetPut() != "" {
							g.P("Method: ", netHTTPPackage.Ident("MethodPut"), ",")
							router = httpRule.GetPut()
						}
						if httpRule.GetDelete() != "" {
							g.P("Method: ", netHTTPPackage.Ident("MethodDelete"), ",")
							router = httpRule.GetDelete()
						}
						if httpRule.GetPatch() != "" {
							g.P("Method: ", netHTTPPackage.Ident("MethodPatch"), ",")
							router = httpRule.GetPatch()
						}
						pathList := strings.Split(router, "/")
						for index, path := range pathList {
							if strings.HasPrefix(path, "{") && strings.HasSuffix(path, "}") {
								if strings.Contains(path, ":") {
									path = path[1 : len(path)-1]
									subPathList := strings.Split(path, ":")
									pathList[index] = subPathList[1]
								} else {
									pathList[index] = "*"
								}
							}
						}
						g.P("URL: `", strings.Join(pathList, "/"), "`,")
						g.P("MuxPath: `", router, "`,")
						g.P("}")
					}
				}
			}
		}
	}
	g.P("})")
	g.P("}")
	return g
}

// GenerateFile generates the contents of a _kit_mux.pb.go file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_kit_mux.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-kit-mux. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-kit-mux ", version.String())
	g.P("// - protoc                ", tool.ProtocVersion(gen))
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the go-kit service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the go-kit package it is being compiled against.")
	g.P("// Requires go-kit v0.12.0.")
	g.P()
	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			genMethod(gen, file, g, service, method)
		}
	}
	g.P("// RegisterKitHTTP", service.GoName, "HandlerSet - regist all handler")
	g.P("func RegisterKitHTTP", service.GoName, "HandlerSet(r *", muxPackage.Ident("Router"), ", set ", service.GoName, "KitHTTPHandlerSet) {")
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			g.P("RegisterKitHTTP", service.GoName, method.GoName, "Handler(r, set)")
		}
	}
	g.P("}")
}

func genMethod(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	methodOptions := method.Desc.Options()
	httpRuleAnnotations := methodOptions.ProtoReflect().Get(annotations.E_Http.TypeDescriptor())
	httpRule := annotations.E_Http.InterfaceOf(httpRuleAnnotations).(*annotations.HttpRule)
	swaggerAnnotations := methodOptions.ProtoReflect().Get(kit.E_Swagger.TypeDescriptor())
	swagger := kit.E_Swagger.InterfaceOf(swaggerAnnotations).(*kit.Swagger)
	if httpRule != nil {
		if methodOptions.(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P("// ", method.GoName, " godoc")
		if swagger != nil {
			g.P("// @Summary ", swagger.GetSummary())
			g.P("// @Description ", swagger.GetDescription())
			g.P("// @Tags ", swagger.GetTags())
			g.P("// @Accept ", swagger.GetAccept())
			g.P("// @Produce ", swagger.GetProduce())
			for _, param := range swagger.GetParam() {
				g.P("// @Param ", param)
			}
			g.P("// @Success ", swagger.GetSuccess())
			g.P("// @Router ", swagger.GetRouter())
		}
		g.P("func RegisterKitHTTP", service.GoName, method.GoName, "Handler(r *", muxPackage.Ident("Router"), ", set ", service.GoName, "KitHTTPHandlerSet) {")
		g.P("r.Methods(", internalPowerPackage.Ident("Power"+method.GoName), ".Method()).Path(", internalPowerPackage.Ident("Power"+method.GoName), ".MuxPath()).Handler(set.", method.GoName, "Handler)")
		g.P("}")
	}
}
